hash table/哈希表	1	3	12	13	20	128	138	141	142																		double pointers/双指针/快慢指针	2	4	19	21	23	88	141	142	203	206	234																sliding window/滑动窗口/double pointers/双指针	3	76	220	239																							merge sort/归并排序/逆序对	4	23	88	315																							linked list/链表	2	19	21	23	61	117	138	141	142	160	203	206	234	328													binary search/二分查找	4	33	34	35	69	162	278	367																			Memorization/记忆化搜索/top down/自顶向下	64	70	128																								dynamic programming/动态规划/buttom up/自底向上	5	53	62	63	64	70	91	96	121	122	128	152	279	322													中心扩展法/center expansion method	5																										math/数学/高斯定理/guass sum	7	9	12	50	62	66	69	70	268	367																	string/字符串	7	9	12	13	28	65	71	76																			Greedy Algorithm/贪心算法	12	53	122																								encoding/decoding/编码/解码	12	13																									dummy node/哑节点	19	21	61	203																							stack/栈/deque	19	20	71	144	145	150	155	224																			递归/recursion	21	23	39	40	46	47	50	53	54	64	66	70	94	98	101	104	105	106	108	110	112	116	144	145	150	206	235heapq/heap/priority queue/优先队列/堆/min heap/max heap/最小堆/最大堆	23	215	218	239																							heap sort/堆排序	215																										kmp algorithm	28																										状态机/finite state machine	28	65	137																								回溯/backtracking/combination/permutation/排列组合	39	40	46	47	77	91	126	207	236																		dfs/depth first search/深度优先搜索	39	40	46	47	70	101	112	116	130	133	138	207	236	297													Divide-and-conquer algorithm/分治算法	50	54	62	64																							iterative/迭代	50	66	94	98	101	102	104	110	112	116	117	144	145	206	235												segment tree/线段树	53	218	307	315																							array/数组	54																										模拟/simulation	54	65																									regex/regular expression/正则表达式/nfa/dfa/自动机	65																										Newton's method/牛顿迭代	69	367																									binary tree/二叉树/preorder traverse/前序遍历/inorder traverse/中序遍历/postorder traverse/后序遍历/前驱节点/predecessor/后继节点/successor/morris Traversal	94	98	105	106	108	144	145	173	236	297																	BST/binary search tree/二叉搜索树	98	108	173	220	235																						binary tree/二叉树/层序遍历/Level Order Traversal/BFS	101	102	104	110	112	116	117	127	126	130	133	207	297														binary tree/二叉树/Top down/buttom up/自顶向下（前序遍历）/自底向上（后序遍历）	104	110																									无向图/undirected graph	127	126																									Union Find/并查集	128	130																									Flood Fill algorithm	130																										位运算 bit manipulation	136	137	201	260	268	318																					单调栈/monotone or monotonic stack	173																										单调队列/monotone or monotonic queue	239																										directed graph/有向图	207																										Trie/prefix tree 前缀树/字典树	208																										quick sort/快排/快速排序	215																										分桶法	220																										树状数组/binary index tree	315																																																					Note: dynamic programming & memorization 分类 ： https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns#Minimum-(Maximum)-Path-to-Reach-a-Target																											greedy algorithm: https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html and https://www.cxyxiaowu.com/852.html  and https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/																											无后效行： https://www.zhihu.com/question/43361359																											"1. dynamic programming: https://www.zhihu.com/question/39948290/answer/83942329应用 最值问题2. DP/dynamic programming: 同时，我们只关注前一位的累加值是多少，而不关心这个累加值结果是由什么路径而来的。这显然就满足了「无后效性」的定义：我们转移某个状态需要用到某个值，但是并不关心该值是如何而来的。"																											"1. 如何列出正确的状态转移方程？确定 base case。确定「状态」，也就是原问题和子问题中会变化的变量。确定「选择」，也就是导致「状态」产生变化的行为。明确 dp 函数/数组的定义。https://labuladong.gitee.io/algo/3/23/67/2. 动态规划性质： 状态转移方程，重叠子问题，最优子结构3. 为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。： https://mp.weixin.qq.com/s/1V3aHVonWBEXlNUvK3S28w4. 很容易发现，其实状态转移方程直接代表着暴力解法。千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。： https://mp.weixin.qq.com/s/1V3aHVonWBEXlNUvK3S28w5. 动态规划遵循一套固定的流程：递归的暴力解法 -> 带备忘录的递归解法 -> 非递归的动态规划解法。https://mp.weixin.qq.com/s/1V3aHVonWBEXlNUvK3S28w6. 「最优子结构」性质：原问题的解由子问题的最优解构成。要符合「最优子结构」，子问题间必须互相独立。：https://mp.weixin.qq.com/s/1V3aHVonWBEXlNUvK3S28w 也就是无后效性https://www.zhihu.com/question/43361359 7. 重叠子问题: 观察斐波那契数列递归树，很明显发现了算法低效的原因：存在大量重复计算 https://mp.weixin.qq.com/s/1V3aHVonWBEXlNUvK3S28w8. 动态规划问题的一般形式就是求最值，求解动态规划的核心问题是穷举： https://labuladong.gitee.io/algo/3/23/67/9. 「状态压缩」：如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据https://labuladong.gitee.io/algo/3/23/67/"																											"dynamic programming 路径问题 https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485580&idx=1&sn=84c99a0a8ab7b543c3678db577309b97&scene=21#wechat_redirect技巧解法：https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485426&idx=1&sn=071aec0bf5bc2e20c58f4cbb3dcb0fbc&chksm=fd9cacedcaeb25fb895cb99963dcfcde6b10268893a085eed4000b48bf070cecbdf7c81bf991&scene=178&cur_album_id=1773144264147812354#rd"																											dynamic programming 背包问题 https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4NDE3MTEyMA==&action=getalbum&album_id=1751702161341628417&scene=173&from_msgid=2247488290&from_itemidx=1&count=3&nolastread=1#wechat_redirect																											dynamic programming 股票问题：https://leetcode-cn.com/circle/article/qiAgHn/																											memorization/记忆化搜索模版：https://oi-wiki.org/dp/memo/																											记忆化搜索到dynamic programming：https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247485319&idx=1&sn=95a3dc9c97ca57185de792ca70924afe&chksm=fd9cac98caeb258ebea466f59378670a90af1cb3015ae70922e1d04ac711a5b8d8d853ac5e7d&token=677741617&lang=zh_CN&scene=21#wechat_redirect																											Union Find/并查集：https://oi-wiki.org/ds/dsu/； https://zhuanlan.zhihu.com/p/93647900																											"位运算 bit manipulation: https://www.cnblogs.com/Neeo/articles/10536202.html and https://www.cnblogs.com/zhxmdefj/p/10902322.html; 规律总结： https://leetcode-cn.com/leetbook/read/leetcode-cookbook/5c9u92/; 注意规律总结中这个公式不对：X & = (X - 1)  -> Subtracting 1 from a decimal number flips all the bits after the rightmost set bit(which is 1) including the rightmost bit. https://sanchit3b.medium.com/brian-kernighans-algorithm-9e0ca5989148解决 只出现一次的数字 Single Number;丢失的数字 missing number 问题"																											single number位运算  https://leetcode-cn.com/problems/single-number-ii/ 通解：https://leetcode-cn.com/problems/single-number-ii/solution/luo-ji-dian-lu-jiao-du-xiang-xi-fen-xi-gai-ti-si-l/ and https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/																											Floyd Cycle Detection Algorithm/Tortoise and Hare Algorithm: https://www.jianshu.com/p/9b6a9bf31144																											binary tree traversal:  颜色标记+stack + iterative 通解:  https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/																											所有的「表达式计算」问题都离不开「栈」: https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/solution/yi-ti-shuang-jie-xi-tong-zhan-shu-zu-mo-i1eq3/																											"binary search/二分查找/上取整/下取整：通解：https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/ ； mid = (left + right) / 2 分成 [left..mid] 和 [mid + 1..right]，分别对应 right = mid 和 left = mid + 1；分成 [left..mid - 1] 和 [mid..right]，分别对应 right = mid - 1 和 left = mid，这种情况下。需要将 int mid = (left + right) / 2 改成 int mid = (left + right + 1) / 2，否则会出现死循环，这一点不用记，出现死循环的时候，把 left 和 right 的值打印出来看一下就很清楚了；从不满足的性质去设计判别函数得到的条件会相对简单一点：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/ TrustTheProcess 的回答"																											题目让我们实现一个 O(\log{n})O(logn) 算法，这是对使用「二分」的强烈暗示。																											binary search 不一定比较左右边界，也可能比较i+1，i-1值：https://leetcode-cn.com/problems/find-peak-element/solution/																											"1. 递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度：因为每次递归所需的空间都被压到调用栈里（这是内存管理里面的数据结构，和算法里的栈原理是一样的），一次递归结束，这个栈就是就是把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度。https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md2. 递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间：https://mp.weixin.qq.com/s/1V3aHVonWBEXlNUvK3S28w3. 首先为了训练逆向思考的能力。递推的思维是正常人的思维，总是看着眼前的问题思考对策，解决问题是将来时；递归的思维，逼迫我们倒着思考，看到问题的尽头，把解决问题的过程看做过去时。https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484528&idx=1&sn=2a892f1eb4531e33d22956a136e66065&source=41#wechat_redirect4. 递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。 https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484528&idx=1&sn=2a892f1eb4531e33d22956a136e66065&source=41#wechat_redirect 5. 写递归的技巧：明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊？https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484528&idx=1&sn=2a892f1eb4531e33d22956a136e66065&source=41#wechat_redirect"																											BST 通解：inorder traverse of BST/binary search tree ==  a sorted array: 173 题																											"单调栈/monotone stack解决 Next Greater Number 下一个更大元素II 一类问题：https://leetcode-cn.com/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/单调栈vs单调队列monotonic/monotone queue vs monotonic/monotone stack: https://blog.csdn.net/Hanx09/article/details/108434955单调队列/monotone or monotonic queue 解决 区间最小（最大）值问题：https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/"																											Brian Kernighan 算法：Brian Kernighan 算法的关键在于我们每次对 \textit{number}number 和 \textit{number}-1number−1 之间进行按位与运算后，\textit{number}number 中最右边的 11 会被抹去变成 00。https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-by-leetcode-solution/																											"尾递归/tail recursion：查notes, 重点：尾递归是把变化的参数传递给递归函数的变量了。怎么写尾递归？形式上只要最后一个return语句是单纯函数就可以。 另外案例：https://leetcode-cn.com/problems/reverse-linked-list/solution/3chong-jie-jue-fang-shi-zhan-shuang-lian-biao-di-2/"																											DAG/有向无环图/adjacency邻接表/indegree入度/topology sort/拓扑排序: 邻接表不需要用list of linked list来表示。 list of list 也可，比如https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa																											"Trie，prefix tree 前缀树，字典树 There are various applications of this data structure, such as autocomplete and spellchecker. : https://www.pythonf.cn/read/123752 "																											"heapq是最小堆; The interesting property of a heap is that its smallest element is always the root, heap[0]k largest elements,区间最大值 这类问题一般是问heap;Heaps are binary trees for which every parent node has a value less than or equal to any of its children. This implementation uses arrays for which heap[k]<= heap[2*k+1] and heap[k] <= heap[2*k+2] for all k, counting elements from zero. : https://sisyphus.gitbook.io/project/python-notes/python-priority-queue-heapq;max heap in python: https://stackoverflow.com/questions/48255849/how-to-get-the-max-heap-in-python "																											Why is Binary Heap Preferred over BST for Priority Queue?: https://www.geeksforgeeks.org/why-is-binary-heap-preferred-over-bst-for-priority-queue/																											快速排序是在实践中比较快的已知排序算法，平均运行时间为O(NlogN)，最坏的运行时间为O(N^2)。https://zhuanlan.zhihu.com/p/57436476																											"主定理，Master Theorem, master theory: https://zhuanlan.zhihu.com/p/100531135; https://www.coursera.org/lecture/algorithmic-toolbox/proof-of-the-master-theorem-7KR1rM^{\log_\alpha\!N}=N^{\log_\alpha\!M} 證明： https://zh.wikipedia.org/wiki/%E5%AF%B9%E6%95%B0主定理例子：https://www.geeksforgeeks.org/analysis-algorithm-set-4-master-method-solving-recurrences/ and https://www.geeksforgeeks.org/merge-sort/a: number of problems, n/b: problem size"																											"线段树/segment tree 支持区间求和，区间最大值，区间修改，单点修改等操作：https://www.youtube.com/watch?v=rYBtViWXYeI&ab_channel=HuaHua扫描线/Scan line：https://zhuanlan.zhihu.com/p/103616664 注意最高是25.5 二号矩形的高计算有误离散化：https://www.cnblogs.com/qlky/articles/5716796.htmllazy notation，懒惰标记：https://zhuanlan.zhihu.com/p/350443545 / https://www.acwing.com/blog/content/1684/单点更新/查询 -> 区间更新/查询（都需要push down） segment update: https://www.acwing.com/blog/content/1684/push down，懒惰标记下传: https://www.acwing.com/blog/content/1684/线段树/segement tree最坏空间复杂度：O(4n), 最好 O(2n) - https://blog.csdn.net/DREAM_yao/article/details/108801613"																											"binary tree 最坏空间复杂度 o(n)binary tree and list 相互转化https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/solution/shou-hui-tu-jie-gei-chu-dfshe-bfsliang-chong-jie-f/ "																											"红黑树/red black tree （最多三次旋转变色不是一个完美平衡bst）：https://www.jianshu.com/p/e136ec79235cAVL tree/平衡二叉搜索树(若干次旋转平衡bst，所以比red black tree查找要快，但插入要慢) ：https://www.jianshu.com/p/65c90aa1236d其他树：https://blog.csdn.net/wanderlustLee/article/details/81297253"																											"calculator problem: single stack: 清风Python：https://leetcode-cn.com/problems/basic-calculator/solution/ru-he-xiang-dao-yong-zhan-si-lu-lai-zi-y-gpca/double stack: https://leetcode-cn.com/problems/basic-calculator/solution/shuang-zhan-jie-jue-tong-yong-biao-da-sh-olym/"																											等比数列求和公式： https://baike.baidu.com/item/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/7527367																											"归并排序/merge sort逆序对/inversion pair：https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/shu-zu-zhong-de-ni-xu-dui-by-leetcode-solution/ 视频索引数组indexed array：https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/gui-bing-pai-xu-suo-yin-shu-zu-python-dai-ma-java-/ 视频与图片"																											"树状数组 Fenwick tree / Binary Indexed Tree (了解即可)：https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/shu-zhuang-shu-zu-by-liweiwei1419/ 視頻具体解法：问题分析部分，树状数组解决方法部分，尤其是幻灯片，关键是 - A[i]：统计“当前遇到数字的出现次数”的数组，所以问题转化为求前缀和（：https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/solution/shu-zhuang-shu-zu-de-xiang-xi-fen-xi-by-yangbingji/可求前缀和"																											"bit manipulation/位运算状态压缩：https://leetcode-cn.com/problems/maximum-product-of-word-lengths/ 判断两字符串是否相等"																																																																																																												需要总结每一条把最关键的思路写出来然后面试作为参考																											看https://labuladong.gitee.io/algo/3/23/67/																											看https://leetcode.com/explore/learn/card/recursion-i/																											